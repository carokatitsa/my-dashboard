<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chess Engine</title>
<style>
body{font-family:Arial}
#board{
display:grid;
grid-template-columns:repeat(8,70px);
grid-template-rows:repeat(8,70px);
width:560px;
border:2px solid black;
}
.square{
display:flex;
align-items:center;
justify-content:center;
font-size:48px;
cursor:pointer;
user-select:none;
}
.white{background:#f0d9b5}
.black{background:#b58863}
.selected{outline:3px solid red}
</style>
</head>
<body>

<h2>Pure Chess Engine</h2>
<button onclick="undoMove()">Undo</button>
<button onclick="redoMove()">Redo</button>
<button onclick="initGame()">Reset</button>

<div id="board"></div>

<script>
const boardElement=document.getElementById("board");

let board,turn,enPassant,castle,undoStack,redoStack,selected=null;

function initGame(){
board=[
['r','n','b','q','k','b','n','r'],
['p','p','p','p','p','p','p','p'],
['','','','','','','',''],
['','','','','','','',''],
['','','','','','','',''],
['','','','','','','',''],
['P','P','P','P','P','P','P','P'],
['R','N','B','Q','K','B','N','R']
];
turn='w';
enPassant=null;
castle={w:{k:true,q:true},b:{k:true,q:true}};
undoStack=[];redoStack=[];
render();
}

function render(){
boardElement.innerHTML='';
for(let r=0;r<8;r++){
for(let c=0;c<8;c++){
const sq=document.createElement('div');
sq.className='square '+((r+c)%2?'black':'white');
sq.textContent=symbol(board[r][c]);
sq.onclick=()=>click(r,c);
boardElement.appendChild(sq);
}
}
}

function symbol(p){
if(!p) return '';
const m={
p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚',
P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔'
};
return m[p];
}

function color(p){return p===p.toUpperCase()?'w':'b'}

function click(r,c){
if(selected){
if(move(selected.r,selected.c,r,c)){
selected=null;
render();
}else{
selected=null;
render();
}
}else{
if(board[r][c]&&color(board[r][c])===turn)
selected={r,c};
}
}

function move(fr,fc,tr,tc){
const legal=getLegal(fr,fc);
if(!legal.some(m=>m.r===tr&&m.c===tc)) return false;

saveState();

const piece=board[fr][fc];
board[fr][fc]='';

if(piece.toLowerCase()==='p'){
if(enPassant&&tr===enPassant.r&&tc===enPassant.c)
board[turn==='w'?tr+1:tr-1][tc]='';

if(Math.abs(tr-fr)===2)
enPassant={r:(fr+tr)/2,c:fc};
else enPassant=null;

if((turn==='w'&&tr===0)||(turn==='b'&&tr===7))
board[tr][tc]=turn==='w'?'Q':'q';
else board[tr][tc]=piece;
}else{
enPassant=null;
board[tr][tc]=piece;
}

if(piece.toLowerCase()==='k'){
castle[turn].k=false;
castle[turn].q=false;
if(Math.abs(tc-fc)===2){
if(tc===6){
board[tr][5]=board[tr][7];
board[tr][7]='';
}else{
board[tr][3]=board[tr][0];
board[tr][0]='';
}
}
}

if(piece.toLowerCase()==='r'){
if(fr===7&&fc===0) castle.w.q=false;
if(fr===7&&fc===7) castle.w.k=false;
if(fr===0&&fc===0) castle.b.q=false;
if(fr===0&&fc===7) castle.b.k=false;
}

turn=turn==='w'?'b':'w';
return true;
}

function getLegal(r,c){
if(!board[r][c]||color(board[r][c])!==turn) return [];
let pseudo=getPseudo(r,c);
return pseudo.filter(m=>{
const snap=saveTemp();
move(r,c,m.r,m.c);
const check=isCheck(turn==='w'?'b':'w');
restoreTemp(snap);
return !check;
});
}

function isCheck(side){
let kr,kc;
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]===(side==='w'?'K':'k')){kr=r;kc=c}
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]&&color(board[r][c])!==side)
if(getPseudo(r,c).some(m=>m.r===kr&&m.c===kc))
return true;
return false;
}

function getPseudo(r,c){
const p=board[r][c];
const side=color(p);
const moves=[];
const add=(rr,cc)=>{
if(rr>=0&&rr<8&&cc>=0&&cc<8&&(!board[rr][cc]||color(board[rr][cc])!==side))
moves.push({r:rr,c:cc});
};
const t=p.toLowerCase();

if(t==='p'){
const dir=side==='w'?-1:1;
if(!board[r+dir]?.[c]) add(r+dir,c);
if((side==='w'?r===6:r===1)&&!board[r+dir]?.[c]&&!board[r+2*dir]?.[c])
add(r+2*dir,c);
for(const dc of [-1,1]){
if(board[r+dir]?.[c+dc]&&color(board[r+dir][c+dc])!==side)
add(r+dir,c+dc);
if(enPassant&&enPassant.r===r+dir&&enPassant.c===c+dc)
moves.push({r:r+dir,c:c+dc});
}
}

if(t==='n'){
[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
.forEach(([dr,dc])=>add(r+dr,c+dc));
}

if(t==='b'||t==='q'){
[[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{
let rr=r+dr,cc=c+dc;
while(rr>=0&&rr<8&&cc>=0&&cc<8){
if(!board[rr][cc]) moves.push({r:rr,c:cc});
else{
if(color(board[rr][cc])!==side) moves.push({r:rr,c:cc});
break;
}
rr+=dr;cc+=dc;
}
});
}

if(t==='r'||t==='q'){
[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
let rr=r+dr,cc=c+dc;
while(rr>=0&&rr<8&&cc>=0&&cc<8){
if(!board[rr][cc]) moves.push({r:rr,c:cc});
else{
if(color(board[rr][cc])!==side) moves.push({r:rr,c:cc});
break;
}
rr+=dr;cc+=dc;
}
});
}

if(t==='k'){
for(let dr=-1;dr<=1;dr++)
for(let dc=-1;dc<=1;dc++)
if(dr||dc) add(r+dr,c+dc);

if(castle[side].k&&!board[r][5]&&!board[r][6])
moves.push({r,c:6});
if(castle[side].q&&!board[r][1]&&!board[r][2]&&!board[r][3])
moves.push({r,c:2});
}

return moves;
}

function saveState(){
undoStack.push(JSON.stringify({board,turn,enPassant,castle}));
redoStack=[];
}

function saveTemp(){
return JSON.stringify({board,turn,enPassant,castle});
}

function restoreTemp(s){
const o=JSON.parse(s);
board=o.board;turn=o.turn;enPassant=o.enPassant;castle=o.castle;
}

function undoMove(){
if(!undoStack.length) return;
redoStack.push(JSON.stringify({board,turn,enPassant,castle}));
restoreTemp(undoStack.pop());
render();
}

function redoMove(){
if(!redoStack.length) return;
undoStack.push(JSON.stringify({board,turn,enPassant,castle}));
restoreTemp(redoStack.pop());
render();
}

initGame();
</script>

</body>
</html>
