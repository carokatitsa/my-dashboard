<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-select=no">
    <title>Chess Cloud Trainer</title>
    <style>
        :root { 
            --bg: #121212; --sq-l: #ebecd0; --sq-d: #779556; --hl: rgba(255, 255, 0, 0.5); 
            --accent: #27ae60; --exam-accent: #2980b9;
        }
        body { 
            display: flex; flex-direction: column; background: var(--bg); color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica; 
            margin: 0; padding: 10px; align-items: center; min-height: 100vh;
        }

        /* Адаптивный контейнер */
        .main-container { display: flex; flex-direction: row; gap: 20px; max-width: 1000px; width: 100%; }
        @media (max-width: 850px) { .main-container { flex-direction: column; align-items: center; } }

        /* Доска */
        #board-wrapper { position: relative; width: 100%; max-width: 480px; }
        #board { 
            display: grid; grid-template-columns: repeat(8, 12.5%); grid-template-rows: repeat(8, 12.5%); 
            width: 100%; aspect-ratio: 1 / 1; border: 4px solid #333; box-sizing: border-box;
            transition: transform 0.5s ease; touch-action: none;
        }
        #board.flipped { transform: rotate(180deg); }
        #board.flipped .piece { transform: rotate(180deg); }

        .square { display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
        .white-sq { background-color: var(--sq-l); }
        .black-sq { background-color: var(--sq-d); }
        .selected { background-color: var(--hl) !important; }
        .can-move::after { content: ""; width: 25%; height: 25%; background: rgba(0,0,0,0.15); border-radius: 50%; position: absolute; }
        
        /* Фигуры SVG */
        .piece { width: 90%; height: 90%; background-size: contain; background-repeat: no-repeat; z-index: 2; pointer-events: none; }
        
        /* Панель управления */
        #right-pane { flex: 1; min-width: 320px; background: #222; padding: 15px; border-radius: 12px; display: flex; flex-direction: column; gap: 12px; box-sizing: border-box; }
        
        .mode-toggle { display: flex; border-radius: 8px; overflow: hidden; border: 1px solid #444; }
        .mode-toggle button { flex: 1; padding: 12px; border: none; background: #333; color: #aaa; font-weight: bold; cursor: pointer; }
        .mode-toggle button.active.record { background: var(--accent); color: #fff; }
        .mode-toggle button.active.exam { background: var(--exam-accent); color: #fff; }

        .btn-group { display: flex; gap: 8px; }
        button.action { flex: 1; padding: 12px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; background: #444; color: #fff; }
        button.action:active { transform: scale(0.98); }

        .list-container { background: #1a1a1a; border-radius: 8px; padding: 10px; height: 200px; overflow-y: auto; border: 1px solid #333; }
        .debut-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #2a2a2a; }
        .debut-item:last-child { border: none; }
        
        #status-bar { padding: 10px; background: #000; border-radius: 6px; text-align: center; font-size: 14px; font-weight: bold; }
        
        input { padding: 12px; background: #111; border: 1px solid #444; border-radius: 8px; color: #fff; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>

<div id="turn-display" style="font-size: 20px; margin-bottom: 10px;">Ход белых</div>

<div class="main-container">
    <div id="board-wrapper">
        <div id="board"></div>
        <div class="btn-group" style="margin-top: 15px;">
            <button class="action" onclick="undo()">⬅</button>
            <button class="action" onclick="redo()">➡</button>
            <button class="action" onclick="resetGame()" style="background: #a33;">СБРОС</button>
        </div>
    </div>

    <div id="right-pane">
        <div class="mode-toggle">
            <button id="m-rec" class="active record" onclick="setMode('record')">ЗАПИСЬ</button>
            <button id="m-exa" onclick="setMode('exam')">ЭКЗАМЕН</button>
        </div>

        <div id="status-bar">Режим обучения активен</div>

        <div id="record-box">
            <input type="text" id="debut-name" placeholder="Название варианта">
            <div class="btn-group" style="margin-top: 8px;">
                <button class="action" id="side-w" onclick="setSide('W')" style="border: 2px solid white;">ЗА БЕЛЫХ</button>
                <button class="action" id="side-b" onclick="setSide('B')">ЗА ЧЕРНЫХ</button>
            </div>
            <button class="action" onclick="saveDebut()" style="background: var(--accent); margin-top: 8px; width: 100%;">СОХРАНИТЬ В ОБЛАКО</button>
        </div>

        <div class="list-container" id="debut-list">
            </div>
    </div>
</div>

<script>
    // Ссылки на SVG фигуры (стандартные и четкие)
    const PIECES_SVG = {
        'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
        'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
        'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
        'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
        'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
        'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
        'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
        'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
        'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
        'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
        'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
        'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg'
    };

    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status-bar');
    const debutListEl = document.getElementById('debut-list');
    
    let history = [{
        board: [
            ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'],
            ['','','','','','','',''], ['','','','','','','',''],
            ['','','','','','','',''], ['','','','','','','',''],
            ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R']
        ],
        turn: 'white', castling: {W:{K:true,Q:true}, B:{K:true,Q:true}}, move: null
    }];
    let historyIndex = 0;
    let selected = null;
    let validMoves = [];
    let mode = 'record';
    let mySide = 'W';
    let activeDebut = null;

    // Имитация облака (в реальном проекте тут будет Fetch к вашему API)
    let cloudData = JSON.parse(localStorage.getItem('chess_cloud_v1') || '[]');

    function render() {
        boardEl.innerHTML = '';
        const current = history[historyIndex].board;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0 ? 'white-sq' : 'black-sq'}`;
                if (selected?.r === r && selected?.c === c) sq.classList.add('selected');
                if (validMoves.some(m => m.r === r && m.c === c)) sq.classList.add('can-move');

                const char = current[r][c];
                if (char) {
                    const p = document.createElement('div');
                    p.className = 'piece';
                    p.style.backgroundImage = `url(${PIECES_SVG[char]})`;
                    sq.appendChild(p);
                }
                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
        document.getElementById('turn-display').innerText = `Ход ${history[historyIndex].turn === 'white' ? 'БЕЛЫХ' : 'ЧЕРНЫХ'}`;
        renderList();
    }

    function onSquareClick(r, c) {
        const state = history[historyIndex];
        const piece = state.board[r][c];
        const isWhite = piece && piece === piece.toUpperCase();
        const canPick = (state.turn === 'white' && isWhite) || (state.turn === 'black' && piece && !isWhite);

        if (selected) {
            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) { executeMove(selected.r, selected.c, r, c, move.type); return; }
        }
        if (canPick) {
            selected = {r, c};
            validMoves = getValidMoves(r, c, state);
        } else {
            selected = null; validMoves = [];
        }
        render();
    }

    function executeMove(fR, fC, tR, tC, type, isAuto = false) {
        const current = history[historyIndex];
        let newBoard = current.board.map(row => [...row]);
        let newCastling = JSON.parse(JSON.stringify(current.castling));
        const piece = newBoard[fR][fC];

        if (type === 'castle') {
            if (tC === 6) { newBoard[tR][5] = newBoard[tR][7]; newBoard[tR][7] = ''; }
            if (tC === 2) { newBoard[tR][3] = newBoard[tR][0]; newBoard[tR][0] = ''; }
        }
        newBoard[tR][tC] = piece; newBoard[fR][fC] = '';
        if (piece.toLowerCase() === 'p' && (tR === 0 || tR === 7)) newBoard[tR][tC] = piece === 'P' ? 'Q' : 'q';

        history = history.slice(0, historyIndex + 1);
        history.push({
            board: newBoard, turn: current.turn === 'white' ? 'black' : 'white',
            castling: newCastling, move: `${fR}${fC}${tR}${tC}`
        });
        historyIndex++; selected = null; validMoves = [];
        render();

        if (mode === 'exam' && activeDebut && !isAuto) checkExam();
    }

    function checkExam() {
        const path = activeDebut.moves;
        if (history[historyIndex].move !== path[historyIndex - 1]) {
            statusEl.innerText = "❌ Ошибка! Не тот ход.";
            statusEl.style.color = "#e74c3c";
            return;
        }
        if (path.length > historyIndex) {
            statusEl.innerText = "Верно! Соперник думает...";
            setTimeout(() => {
                const m = path[historyIndex];
                executeMove(+m[0], +m[1], +m[2], +m[3], 'normal', true);
                statusEl.innerText = "Ваш ход!";
            }, 600);
        } else {
            statusEl.innerText = "✅ Вариант завершен!";
        }
    }

    function getValidMoves(r, c, state) {
        const moves = []; const b = state.board; const p = b[r][c].toLowerCase(); const isW = b[r][c] === b[r][c].toUpperCase();
        const dirs = {
            'r': [[0,1],[0,-1],[1,0],[-1,0]], 'b': [[1,1],[1,-1],[-1,1],[-1,-1]],
            'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
            'q': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            'k': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };
        if (p === 'p') {
            const s = isW ? -1 : 1;
            if (!b[r+s]?.[c]) {
                moves.push({r:r+s, c:c});
                if (((isW && r===6)||(!isW && r===1)) && !b[r+2*s][c]) moves.push({r:r+2*s, c:c});
            }
            [1,-1].forEach(dc => {
                const target = b[r+s]?.[c+dc];
                if (target && (target === target.toUpperCase()) !== isW) moves.push({r:r+s, c:c+dc});
            });
        } else if (dirs[p]) {
            for (let [dr, dc] of dirs[p]) {
                let nr = r+dr, nc = c+dc;
                while(nr>=0 && nr<8 && nc>=0 && nc<8) {
                    if (!b[nr][nc]) { moves.push({r:nr, nc:nc, r:nr, c:nc}); if("nk".includes(p)) break; }
                    else { if((b[nr][nc] === b[nr][nc].toUpperCase()) !== isW) moves.push({r:nr, c:nc}); break; }
                    nr += dr; nc += dc;
                }
            }
            if (p === 'k') {
                const cs = isW ? state.castling.W : state.castling.B;
                if (cs.K && !b[r][5] && !b[r][6]) moves.push({r:r, c:6, type:'castle'});
                if (cs.Q && !b[r][1] && !b[r][2] && !b[r][3]) moves.push({r:r, c:2, type:'castle'});
            }
        }
        return moves;
    }

    function setMode(m) {
        mode = m;
        document.getElementById('m-rec').className = m === 'record' ? 'active record' : '';
        document.getElementById('m-exa').className = m === 'exam' ? 'active exam' : '';
        statusEl.innerText = m === 'record' ? "Режим: Запись" : "Выберите вариант";
    }

    function setSide(s) {
        mySide = s;
        document.getElementById('side-w').style.borderColor = s === 'W' ? 'white' : 'transparent';
        document.getElementById('side-b').style.borderColor = s === 'B' ? 'white' : 'transparent';
    }

    function saveDebut() {
        const name = document.getElementById('debut-name').value.trim();
        if (!name || history.length < 2) return alert("Введите имя и сделайте ходы");
        const entry = { name, side: mySide, moves: history.slice(1).map(h => h.move), id: Date.now() };
        cloudData.push(entry);
        localStorage.setItem('chess_cloud_v1', JSON.stringify(cloudData));
        document.getElementById('debut-name').value = '';
        renderList();
    }

    function loadDebut(id) {
        activeDebut = cloudData.find(d => d.id === id);
        setMode('exam'); resetGame();
        boardEl.classList.toggle('flipped', activeDebut.side === 'B');
        statusEl.innerText = `Экзамен: ${activeDebut.name}`;
        if (activeDebut.side === 'B') {
            setTimeout(() => {
                const m = activeDebut.moves[0];
                executeMove(+m[0], +m[1], +m[2], +m[3], 'normal', true);
            }, 500);
        }
    }

    function renderList() {
        debutListEl.innerHTML = '';
        cloudData.forEach(d => {
            const div = document.createElement('div');
            div.className = 'debut-item';
            div.innerHTML = `<span>${d.side === 'W' ? '⚪' : '⚫'} ${d.name}</span> <button onclick="deleteDebut(${d.id})" style="background:none; border:none; color:red; cursor:pointer">✕</button>`;
            div.onclick = (e) => { if(e.target.tagName !== 'BUTTON') loadDebut(d.id); };
            debutListEl.appendChild(div);
        });
    }

    function deleteDebut(id) {
        cloudData = cloudData.filter(d => d.id !== id);
        localStorage.setItem('chess_cloud_v1', JSON.stringify(cloudData));
        renderList();
    }

    function undo() { if (historyIndex > 0) { historyIndex--; render(); } }
    function redo() { if (historyIndex < history.length - 1) { historyIndex++; render(); } }
    function resetGame() { history = [history[0]]; historyIndex = 0; selected = null; validMoves = []; render(); }

    render();
</script>
</body>
</html>
