<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Complete Chess Trainer</title>

<style>
body{font-family:Arial;margin:20px}
#board{
display:grid;
grid-template-columns:repeat(8,60px);
grid-template-rows:repeat(8,60px);
width:480px;
border:2px solid black;
touch-action:manipulation;
}
.square{
display:flex;
align-items:center;
justify-content:center;
font-size:40px;
cursor:pointer;
user-select:none;
}
.white{background:#f0d9b5}
.black{background:#b58863}
.selected{outline:3px solid red}
.legal{box-shadow:inset 0 0 0 4px rgba(0,255,0,0.5)}
button{margin:4px}
textarea{width:480px;height:60px;margin-top:8px}
</style>
</head>
<body>

<h2>Complete Chess Trainer</h2>

<button onclick="undo()">Undo</button>
<button onclick="redo()">Redo</button>
<button onclick="resetGame()">Reset</button>
<button onclick="toggleTrainer()">Toggle Trainer</button>
<button onclick="saveOpening()">Save Opening</button>
<button onclick="loadOpening()">Load Opening</button>

<div id="board"></div>

<textarea id="openingInput" placeholder="Введите ходы через пробел, например: e2e4 e7e5 g1f3 b8c6"></textarea>

<script>

// ===========================
// GLOBAL STATE
// ===========================

let board,turn,enPassant,castleRights,history=[],redoStack=[];
let selected=null;
let trainerMode=false;
let openingMoves=[];
let openingIndex=0;

const boardEl=document.getElementById("board");

// ===========================
// INIT
// ===========================

function resetGame(){
board=[
['r','n','b','q','k','b','n','r'],
['p','p','p','p','p','p','p','p'],
['','','','','','','',''],
['','','','','','','',''],
['','','','','','','',''],
['','','','','','','',''],
['P','P','P','P','P','P','P','P'],
['R','N','B','Q','K','B','N','R']
];
turn='w';
enPassant=null;
castleRights={w:{k:true,q:true},b:{k:true,q:true}};
history=[];
redoStack=[];
openingIndex=0;
render();
}

resetGame();

// ===========================
// RENDER
// ===========================

function render(){
boardEl.innerHTML='';
for(let r=0;r<8;r++){
for(let c=0;c<8;c++){
const sq=document.createElement('div');
sq.className='square '+((r+c)%2?'black':'white');
sq.textContent=symbol(board[r][c]);
sq.onclick=()=>click(r,c);
boardEl.appendChild(sq);
}
}
if(selected) highlightLegal(selected.r,selected.c);
}

function symbol(p){
if(!p) return '';
const m={
p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚',
P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔'
};
return m[p];
}

function color(p){return p===p.toUpperCase()?'w':'b'}

// ===========================
// CLICK
// ===========================

function click(r,c){
if(selected){
if(makeMove(selected.r,selected.c,r,c)){
selected=null;
render();
}else{
selected=null;
render();
}
}else{
if(board[r][c]&&color(board[r][c])===turn){
selected={r,c};
render();
}
}
}

// ===========================
// LEGAL MOVES + ENGINE
// ===========================

function makeMove(fr,fc,tr,tc){
const legal=getLegal(fr,fc);
if(!legal.some(m=>m.r===tr&&m.c===tc)) return false;

// trainer snapback
if(trainerMode){
const moveString=coord(fr,fc)+coord(tr,tc);
if(openingMoves[openingIndex]!==moveString){
return false;
}
openingIndex++;
}

saveState();

const piece=board[fr][fc];
const captured=board[tr][tc];
board[fr][fc]='';

if(piece.toLowerCase()==='p'){
if(enPassant&&tr===enPassant.r&&tc===enPassant.c)
board[turn==='w'?tr+1:tr-1][tc]='';

if(Math.abs(tr-fr)===2)
enPassant={r:(fr+tr)/2,c:fc};
else enPassant=null;

if((turn==='w'&&tr===0)||(turn==='b'&&tr===7))
board[tr][tc]=turn==='w'?'Q':'q';
else board[tr][tc]=piece;
}else{
enPassant=null;
board[tr][tc]=piece;
}

// castling
if(piece.toLowerCase()==='k'){
castleRights[turn].k=false;
castleRights[turn].q=false;
if(Math.abs(tc-fc)===2){
if(tc===6){
board[tr][5]=board[tr][7];
board[tr][7]='';
}else{
board[tr][3]=board[tr][0];
board[tr][0]='';
}
}
}

// rook move
if(piece.toLowerCase()==='r'){
if(fr===7&&fc===0) castleRights.w.q=false;
if(fr===7&&fc===7) castleRights.w.k=false;
if(fr===0&&fc===0) castleRights.b.q=false;
if(fr===0&&fc===7) castleRights.b.k=false;
}

turn=turn==='w'?'b':'w';
return true;
}

function getLegal(r,c){
if(!board[r][c]||color(board[r][c])!==turn) return [];
let pseudo=getPseudo(r,c);
return pseudo.filter(m=>{
const snap=JSON.stringify({board,turn,enPassant,castleRights});
makeMoveRaw(r,c,m.r,m.c);
const check=isCheck(turn==='w'?'b':'w');
restore(snap);
return !check;
});
}

function makeMoveRaw(fr,fc,tr,tc){
const piece=board[fr][fc];
board[fr][fc]='';
board[tr][tc]=piece;
turn=turn==='w'?'b':'w';
}

function restore(s){
const o=JSON.parse(s);
board=o.board;
turn=o.turn;
enPassant=o.enPassant;
castleRights=o.castleRights;
}

function isCheck(side){
let kr,kc;
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]===(side==='w'?'K':'k')){kr=r;kc=c}
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]&&color(board[r][c])!==side)
if(getPseudo(r,c).some(m=>m.r===kr&&m.c===kc))
return true;
return false;
}

function getPseudo(r,c){
const p=board[r][c];
const side=color(p);
const moves=[];
const add=(rr,cc)=>{
if(rr>=0&&rr<8&&cc>=0&&cc<8&&(!board[rr][cc]||color(board[rr][cc])!==side))
moves.push({r:rr,c:cc});
};
const t=p.toLowerCase();

// pawn
if(t==='p'){
const dir=side==='w'?-1:1;
if(!board[r+dir]?.[c]) add(r+dir,c);
if((side==='w'?r===6:r===1)&&!board[r+dir]?.[c]&&!board[r+2*dir]?.[c])
add(r+2*dir,c);
for(const dc of [-1,1]){
if(board[r+dir]?.[c+dc]&&color(board[r+dir][c+dc])!==side)
add(r+dir,c+dc);
if(enPassant&&enPassant.r===r+dir&&enPassant.c===c+dc)
moves.push({r:r+dir,c:c+dc});
}
}

// knight
if(t==='n'){
[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
.forEach(([dr,dc])=>add(r+dr,c+dc));
}

// rook, bishop, queen
[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
if(t==='r'||t==='q'){
let rr=r+dr,cc=c+dc;
while(rr>=0&&rr<8&&cc>=0&&cc<8){
if(!board[rr][cc]) moves.push({r:rr,c:cc});
else{ if(color(board[rr][cc])!==side) moves.push({r:rr,c:cc}); break; }
rr+=dr;cc+=dc;
}
}
});

[[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{
if(t==='b'||t==='q'){
let rr=r+dr,cc=c+dc;
while(rr>=0&&rr<8&&cc>=0&&cc<8){
if(!board[rr][cc]) moves.push({r:rr,c:cc});
else{ if(color(board[rr][cc])!==side) moves.push({r:rr,c:cc}); break; }
rr+=dr;cc+=dc;
}
}
});

// king
if(t==='k'){
for(let dr=-1;dr<=1;dr++)
for(let dc=-1;dc<=1;dc++)
if(dr||dc) add(r+dr,c+dc);

if(castleRights[side].k&&!board[r][5]&&!board[r][6])
moves.push({r,c:6});
if(castleRights[side].q&&!board[r][1]&&!board[r][2]&&!board[r][3])
moves.push({r,c:2});
}

return moves;
}

function coord(r,c){
return String.fromCharCode(97+c)+(8-r);
}

// ===========================
// HISTORY
// ===========================

function saveState(){
history.push(JSON.stringify({board,turn,enPassant,castleRights,openingIndex}));
redoStack=[];
}

function undo(){
if(!history.length) return;
redoStack.push(JSON.stringify({board,turn,enPassant,castleRights,openingIndex}));
restore(history.pop());
render();
}

function redo(){
if(!redoStack.length) return;
history.push(JSON.stringify({board,turn,enPassant,castleRights,openingIndex}));
restore(redoStack.pop());
render();
}

// ===========================
// TRAINER
// ===========================

function toggleTrainer(){
trainerMode=!trainerMode;
alert("Trainer mode: "+trainerMode);
}

function saveOpening(){
localStorage.setItem("opening",document.getElementById("openingInput").value);
alert("Saved");
}

function loadOpening(){
const data=localStorage.getItem("opening");
if(!data) return;
openingMoves=data.trim().split(/\s+/);
openingIndex=0;
trainerMode=true;
alert("Opening loaded. Trainer mode ON.");
}

</script>

</body>
</html>
