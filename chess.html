<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chess Pro: Debuts & History</title>
    <style>
        :root { --bg: #1e1e1e; --sq-l: #ebecd0; --sq-d: #779556; --hl: rgba(255, 255, 0, 0.5); }
        body { display: flex; background: var(--bg); color: #fff; font-family: sans-serif; margin: 0; padding: 20px; justify-content: center; gap: 30px; }
        #left-pane { display: flex; flex-direction: column; align-items: center; }
        #board { display: grid; grid-template-columns: repeat(8, 65px); grid-template-rows: repeat(8, 65px); border: 5px solid #333; }
        .square { width: 65px; height: 65px; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
        .white-sq { background-color: var(--sq-l); }
        .black-sq { background-color: var(--sq-d); }
        .piece { font-size: 48px; z-index: 2; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3)); cursor: pointer; }
        .piece.w { color: #fff; -webkit-text-stroke: 1.5px #000; }
        .piece.b { color: #000; }
        .selected { background-color: var(--hl) !important; }
        .can-move::after { content: ""; width: 18px; height: 18px; background: rgba(0,0,0,0.1); border-radius: 50%; }
        
        #right-pane { width: 300px; display: flex; flex-direction: column; gap: 15px; }
        .controls { display: flex; gap: 10px; }
        button { padding: 8px 15px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px; }
        button:hover { background: #666; }
        input { padding: 8px; border-radius: 4px; border: none; }
        #debut-list { background: #333; padding: 10px; border-radius: 5px; height: 200px; overflow-y: auto; }
        .debut-item { padding: 5px; border-bottom: 1px solid #444; cursor: pointer; font-size: 14px; }
        .debut-item:hover { background: #444; }
        .active-debut { border: 1px solid #779556; background: #2c3e20; }
    </style>
</head>
<body>

<div id="left-pane">
    <div id="status" style="margin-bottom: 10px; font-size: 18px;">Ход белых</div>
    <div id="board"></div>
    <div class="controls" style="margin-top: 15px;">
        <button onclick="undo()">⬅ Назад</button>
        <button onclick="redo()">Вперед ➡</button>
        <button onclick="resetGame()" style="background: #a04040;">Сброс</button>
    </div>
</div>

<div id="right-pane">
    <h3>Мои Дебюты</h3>
    <input type="text" id="debut-name" placeholder="Название дебюта...">
    <button onclick="saveDebut()" style="background: #27ae60;">Сохранить текущие ходы</button>
    
    <div id="debut-list"></div>
    <div id="training-status" style="color: #f1c40f; font-size: 14px;"></div>
</div>

<script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const debutListEl = document.getElementById('debut-list');
    
    const PIECES_MAP = { 'r':'♜','n':'♞','b':'♝','q':'♛','k':'♚','p':'♟','R':'♜','N':'♞','B':'♝','Q':'♛','K':'♚','P':'♟' };
    const initialBoard = [
        ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''], ['','','','','','','',''],
        ['','','','','','','',''], ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R']
    ];

    let board = JSON.parse(JSON.stringify(initialBoard));
    let turn = 'white';
    let history = [{board: JSON.parse(JSON.stringify(board)), turn: 'white'}];
    let historyIndex = 0;
    let selected = null;
    let validMoves = [];
    let debuts = JSON.parse(localStorage.getItem('chess_debuts') || '{}');
    let activeDebut = null;

    function render() {
        boardEl.innerHTML = '';
        const currentData = history[historyIndex];
        const currentBoard = currentData.board;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0 ? 'white-sq' : 'black-sq'}`;
                if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');
                
                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) sq.classList.add('can-move');

                if (currentBoard[r][c]) {
                    const char = currentBoard[r][c];
                    const isWhite = char === char.toUpperCase();
                    const p = document.createElement('span');
                    p.className = `piece ${isWhite ? 'w' : 'b'}`;
                    p.innerText = PIECES_MAP[char];
                    sq.appendChild(p);
                }
                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
        statusEl.innerText = `Ход ${currentData.turn === 'white' ? 'белых' : 'черных'}`;
        updateDebutList();
    }

    function onSquareClick(r, c) {
        if (historyIndex !== history.length - 1) return; // Нельзя ходить, если смотрим историю
        
        const currentBoard = history[historyIndex].board;
        const piece = currentBoard[r][c];
        const isWhite = piece && piece === piece.toUpperCase();
        const myTurn = (turn === 'white' && isWhite) || (turn === 'black' && piece && !isWhite);

        if (selected) {
            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                executeMove(selected.r, selected.c, r, c);
                return;
            }
        }
        if (myTurn) {
            selected = {r, c};
            validMoves = getValidMoves(r, c, currentBoard);
        } else {
            selected = null;
            validMoves = [];
        }
        render();
    }

    function executeMove(fR, fC, tR, tC) {
        let newBoard = JSON.parse(JSON.stringify(history[historyIndex].board));
        const piece = newBoard[fR][fC];
        
        // Базовая логика перемещения
        newBoard[tR][tC] = piece;
        newBoard[fR][fC] = '';
        
        // Превращение пешки
        if (piece.toLowerCase() === 'p' && (tR === 0 || tR === 7)) {
            newBoard[tR][tC] = piece === 'P' ? 'Q' : 'q';
        }

        const nextTurn = turn === 'white' ? 'black' : 'white';
        
        // Запись в историю
        const moveStr = `${fR}${fC}${tR}${tC}`;
        history = history.slice(0, historyIndex + 1);
        history.push({board: newBoard, turn: nextTurn, move: moveStr});
        historyIndex++;
        turn = nextTurn;
        selected = null;
        validMoves = [];
        
        render();

        // Если активен дебют и сейчас ход "компьютера" (относительно записанного дебюта)
        if (activeDebut) {
            checkDebutMatch();
        }
    }

    function getValidMoves(r, c, b) {
        // Упрощенная логика (для краткости оставлена база, аналогичная прошлой)
        const moves = [];
        const piece = b[r][c].toLowerCase();
        const isWhite = b[r][c] === b[r][c].toUpperCase();
        const dirs = {'r':[[0,1],[0,-1],[1,0],[-1,0]], 'b':[[1,1],[1,-1],[-1,1],[-1,-1]], 'q':[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]], 'n':[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]], 'k':[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]};
        
        if (piece === 'p') {
            const d = isWhite ? -1 : 1;
            if (!b[r+d]?.[c]) moves.push({r: r+d, c: c});
            if (((isWhite && r===6) || (!isWhite && r===1)) && !b[r+d][c] && !b[r+2*d][c]) moves.push({r: r+2*d, c: c});
            for (let dc of [-1, 1]) {
                let target = b[r+d]?.[c+dc];
                if (target && (target === target.toUpperCase()) !== isWhite) moves.push({r: r+d, c: c+dc});
            }
        } else if (dirs[piece]) {
            for (let [dr, dc] of dirs[piece]) {
                let nr = r+dr, nc = c+dc;
                while(nr>=0 && nr<8 && nc>=0 && nc<8) {
                    if (!b[nr][nc]) { moves.push({r: nr, c: nc}); if ("nk".includes(piece)) break; }
                    else { if ((b[nr][nc] === b[nr][nc].toUpperCase()) !== isWhite) moves.push({r: nr, c: nc}); break; }
                    nr+=dr; nc+=dc;
                }
            }
        }
        return moves;
    }

    // История
    function undo() { if (historyIndex > 0) { historyIndex--; turn = history[historyIndex].turn; render(); } }
    function redo() { if (historyIndex < history.length - 1) { historyIndex++; turn = history[historyIndex].turn; render(); } }
    function resetGame() { 
        board = JSON.parse(JSON.stringify(initialBoard)); 
        history = [{board: JSON.parse(JSON.stringify(board)), turn: 'white'}];
        historyIndex = 0; turn = 'white'; activeDebut = null;
        document.getElementById('training-status').innerText = '';
        render(); 
    }

    // Дебюты
    function saveDebut() {
        const name = document.getElementById('debut-name').value;
        if (!name) return alert("Введите название!");
        const moves = history.slice(1).map(h => h.move);
        debuts[name] = moves;
        localStorage.setItem('chess_debuts', JSON.stringify(debuts));
        updateDebutList();
    }

    function updateDebutList() {
        debutListEl.innerHTML = '';
        for (let name in debuts) {
            const div = document.createElement('div');
            div.className = `debut-item ${activeDebut === name ? 'active-debut' : ''}`;
            div.innerText = name;
            div.onclick = () => { activeDebut = name; resetGame(); document.getElementById('training-status').innerText = `Тренажер: ${name}`; };
            debutListEl.appendChild(div);
        }
    }

    function checkDebutMatch() {
        const movesPlayed = history.slice(1).map(h => h.move);
        const debutMoves = debuts[activeDebut];
        
        // Проверяем, идет ли игрок по линии дебюта
        for (let i = 0; i < movesPlayed.length; i++) {
            if (movesPlayed[i] !== debutMoves[i]) {
                document.getElementById('training-status').innerText = "❌ Свернули с дебюта";
                activeDebut = null;
                return;
            }
        }

        // Если ход игрока совпал, и есть следующий ход компьютера в дебюте
        if (debutMoves.length > movesPlayed.length) {
            setTimeout(() => {
                const nextMove = debutMoves[movesPlayed.length];
                const [fR, fC, tR, tC] = nextMove.split('').map(Number);
                executeMove(fR, fC, tR, tC);
            }, 500);
        } else {
            document.getElementById('training-status').innerText = "✅ Дебют завершен!";
            activeDebut = null;
        }
    }

    render();
</script>
</body>
</html>
