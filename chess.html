<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Chess JS</title>
    <style>
        :root {
            --bg-page: #1e1e1e;
            --sq-light: #ebecd0; /* Светлая клетка */
            --sq-dark: #779556;  /* Зеленоватая шахматная клетка */
            --hl-select: rgba(255, 255, 0, 0.5);
            --hl-move: rgba(0, 0, 0, 0.1);
        }

        body {
            display: flex; flex-direction: column; align-items: center;
            background: var(--bg-page); color: #fff; font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0; padding-top: 40px;
        }

        #status {
            margin-bottom: 20px; font-size: 24px; text-transform: uppercase; letter-spacing: 2px;
            padding: 10px 20px; border-radius: 8px; background: #333;
        }

        #board {
            display: grid; grid-template-columns: repeat(8, 70px); grid-template-rows: repeat(8, 70px);
            border: 8px solid #333; border-radius: 4px; box-shadow: 0 20px 50px rgba(0,0,0,0.7);
            user-select: none;
        }

        .square {
            width: 70px; height: 70px; display: flex; justify-content: center;
            align-items: center; cursor: pointer; position: relative;
        }

        .white-sq { background-color: var(--sq-light); }
        .black-sq { background-color: var(--sq-dark); }

        /* Фигуры */
        .piece {
            font-size: 50px; z-index: 2; transition: all 0.15s ease;
            /* Тень для объема */
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }

        /* Цвета фигур */
        .piece.w { color: #ffffff; stroke: black; -webkit-text-stroke: 1.5px black; }
        .piece.b { color: #000000; }

        .selected { background-color: var(--hl-select) !important; }

        /* Маркер доступного хода */
        .can-move::after {
            content: ""; width: 22px; height: 22px; 
            background: var(--hl-move); border-radius: 50%;
            position: absolute; z-index: 1;
        }
        
        /* Если на клетке враг - выделяем рамкой */
        .can-move.has-enemy::after {
            width: 60px; height: 60px; border: 4px solid var(--hl-move);
            background: none; border-radius: 50%;
        }
    </style>
</head>
<body>

    <div id="status">Ход белых</div>
    <div id="board"></div>

<script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    
    const PIECES_MAP = {
        'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
        'R': '♜', 'N': '♞', 'B': '♝', 'Q': '♛', 'K': '♚', 'P': '♟'
    };

    let board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];

    let turn = 'white';
    let selected = null;
    let validMoves = [];
    let enPassantTarget = null;
    let castling = { W: {K:true, Q:true}, B: {K:true, Q:true} };

    function render() {
        boardEl.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0 ? 'white-sq' : 'black-sq'}`;
                
                if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');
                
                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) {
                    sq.classList.add('can-move');
                    if (board[r][c]) sq.classList.add('has-enemy');
                }

                if (board[r][c]) {
                    const char = board[r][c];
                    const isWhite = char === char.toUpperCase();
                    const p = document.createElement('span');
                    p.className = `piece ${isWhite ? 'w' : 'b'}`;
                    p.innerText = PIECES_MAP[char];
                    sq.appendChild(p);
                }

                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
    }

    function onSquareClick(r, c) {
        const piece = board[r][c];
        const isWhite = piece && piece === piece.toUpperCase();
        const myTurn = (turn === 'white' && isWhite) || (turn === 'black' && piece && !isWhite);

        if (selected) {
            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                executeMove(selected.r, selected.c, r, c, move.type);
                return;
            }
        }

        if (myTurn) {
            selected = {r, c};
            validMoves = getValidMoves(r, c);
        } else {
            selected = null;
            validMoves = [];
        }
        render();
    }

    function getValidMoves(r, c) {
        const piece = board[r][c];
        const type = piece.toLowerCase();
        const isWhite = piece === piece.toUpperCase();
        const moves = [];

        const directions = {
            'r': [[0,1],[0,-1],[1,0],[-1,0]],
            'b': [[1,1],[1,-1],[-1,1],[-1,-1]],
            'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
            'q': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            'k': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };

        if (type === 'p') {
            const dir = isWhite ? -1 : 1;
            if (r+dir >=0 && r+dir < 8 && !board[r+dir][c]) {
                moves.push({r: r+dir, c: c});
                if (((isWhite && r===6) || (!isWhite && r===1)) && !board[r+2*dir][c]) moves.push({r: r+2*dir, c: c});
            }
            [[dir, 1], [dir, -1]].forEach(([dr, dc]) => {
                const nr = r+dr, nc = c+dc;
                if (nr>=0 && nr<8 && nc>=0 && nc<8) {
                    const target = board[nr][nc];
                    if (target && (isWhite !== (target === target.toUpperCase()))) moves.push({r: nr, c: nc});
                    if (enPassantTarget && nr === enPassantTarget.r && nc === enPassantTarget.c) moves.push({r: nr, c: nc, type: 'ep'});
                }
            });
        } else if (directions[type]) {
            for (let [dr, dc] of directions[type]) {
                let nr = r + dr, nc = c + dc;
                while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                    const target = board[nr][nc];
                    if (!target) {
                        moves.push({r: nr, c: nc});
                        if (type === 'n' || type === 'k') break;
                    } else {
                        if (isWhite !== (target === target.toUpperCase())) moves.push({r: nr, c: nc});
                        break;
                    }
                    nr += dr; nc += dc;
                }
            }
            if (type === 'k') {
                const side = isWhite ? 'W' : 'B';
                const row = isWhite ? 7 : 0;
                if (castling[side].K && !board[row][5] && !board[row][6]) moves.push({r: row, c: 6, type: 'castle'});
                if (castling[side].Q && !board[row][1] && !board[row][2] && !board[row][3]) moves.push({r: row, c: 2, type: 'castle'});
            }
        }
        return moves;
    }

    function executeMove(fR, fC, tR, tC, type) {
        const piece = board[fR][fC];
        if (type === 'ep') board[fR][tC] = '';
        if (type === 'castle') {
            if (tC === 6) { board[tR][5] = board[tR][7]; board[tR][7] = ''; }
            if (tC === 2) { board[tR][3] = board[tR][0]; board[tR][0] = ''; }
        }

        board[tR][tC] = piece;
        board[fR][fC] = '';

        if (piece.toLowerCase() === 'p' && (tR === 0 || tR === 7)) board[tR][tC] = piece === 'P' ? 'Q' : 'q';
        if (piece === 'K') castling.W = {K:false, Q:false};
        if (piece === 'k') castling.B = {K:false, Q:false};

        enPassantTarget = (piece.toLowerCase() === 'p' && Math.abs(tR - fR) === 2) ? {r: (fR + tR) / 2, c: fC} : null;

        turn = turn === 'white' ? 'black' : 'white';
        statusEl.innerText = `Ход ${turn === 'white' ? 'белых' : 'черных'}`;
        selected = null; validMoves = [];
        render();
    }

    render();
</script>
</body>
</html>
