<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ultimate Chess Trainer</title>
<style>
body{font-family:Arial}
#board{
display:grid;
grid-template-columns:repeat(8,70px);
grid-template-rows:repeat(8,70px);
width:560px;
border:2px solid black;
margin-bottom:15px;
}
.square{
display:flex;
align-items:center;
justify-content:center;
font-size:48px;
cursor:pointer;
user-select:none;
}
.white{background:#f0d9b5}
.black{background:#b58863}
.selected{outline:3px solid red}
.legal{box-shadow:inset 0 0 0 4px rgba(0,255,0,0.5)}
button{margin-right:5px;margin-bottom:5px}
</style>
</head>
<body>

<h2>Ultimate Chess Trainer</h2>

<button onclick="undoMove()">Undo</button>
<button onclick="redoMove()">Redo</button>
<button onclick="resetGame()">Reset</button>
<button onclick="toggleBot()">Toggle Bot</button>
<button onclick="saveOpening()">Save Opening</button>
<button onclick="loadOpening()">Load Opening</button>
<button onclick="exportPGN()">Export PGN</button>

<div id="board"></div>

<script>

// ============================
// GLOBAL STATE
// ============================

let board,turn,enPassant,castle,undoStack,redoStack,moveHistory=[];
let selected=null;
let botEnabled=false;

const boardEl=document.getElementById("board");

// ============================
// INIT
// ============================

function resetGame(){
board=[
['r','n','b','q','k','b','n','r'],
['p','p','p','p','p','p','p','p'],
['','','','','','','',''],
['','','','','','','',''],
['','','','','','','',''],
['','','','','','','',''],
['P','P','P','P','P','P','P','P'],
['R','N','B','Q','K','B','N','R']
];
turn='w';
enPassant=null;
castle={w:{k:true,q:true},b:{k:true,q:true}};
undoStack=[];redoStack=[];
moveHistory=[];
selected=null;
render();
}

resetGame();

// ============================
// RENDER
// ============================

function render(){
boardEl.innerHTML='';
for(let r=0;r<8;r++){
for(let c=0;c<8;c++){
const sq=document.createElement('div');
sq.className='square '+((r+c)%2?'black':'white');
sq.textContent=symbol(board[r][c]);
sq.onclick=()=>click(r,c);
boardEl.appendChild(sq);
}
}
if(selected) highlightLegal(selected.r,selected.c);
}

function symbol(p){
if(!p) return '';
const m={
p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚',
P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔'
};
return m[p];
}

function color(p){return p===p.toUpperCase()?'w':'b'}

// ============================
// CLICK
// ============================

function click(r,c){
if(selected){
if(makeMove(selected.r,selected.c,r,c)){
selected=null;
render();
if(botEnabled && turn==='b') setTimeout(botMove,300);
}else{
selected=null;
render();
}
}else{
if(board[r][c] && color(board[r][c])===turn){
selected={r,c};
render();
}
}
}

// ============================
// LEGAL MOVES
// ============================

function highlightLegal(r,c){
const legal=getLegal(r,c);
const squares=boardEl.children;
legal.forEach(m=>{
const index=m.r*8+m.c;
squares[index].classList.add('legal');
});
const index=r*8+c;
squares[index].classList.add('selected');
}

// ============================
// MOVE
// ============================

function makeMove(fr,fc,tr,tc){
const legal=getLegal(fr,fc);
if(!legal.some(m=>m.r===tr && m.c===tc)) return false;

saveState();

const piece=board[fr][fc];
const captured=board[tr][tc];
board[fr][fc]='';

if(piece.toLowerCase()==='p'){
if(enPassant && tr===enPassant.r && tc===enPassant.c){
board[turn==='w'?tr+1:tr-1][tc]='';
}
if(Math.abs(tr-fr)===2)
enPassant={r:(fr+tr)/2,c:fc};
else enPassant=null;

if((turn==='w'&&tr===0)||(turn==='b'&&tr===7))
board[tr][tc]=turn==='w'?'Q':'q';
else board[tr][tc]=piece;
}else{
enPassant=null;
board[tr][tc]=piece;
}

// castling
if(piece.toLowerCase()==='k'){
castle[turn].k=false;
castle[turn].q=false;
if(Math.abs(tc-fc)===2){
if(tc===6){
board[tr][5]=board[tr][7];
board[tr][7]='';
}else{
board[tr][3]=board[tr][0];
board[tr][0]='';
}
}
}

// rook move disables castle
if(piece.toLowerCase()==='r'){
if(fr===7&&fc===0) castle.w.q=false;
if(fr===7&&fc===7) castle.w.k=false;
if(fr===0&&fc===0) castle.b.q=false;
if(fr===0&&fc===7) castle.b.k=false;
}

moveHistory.push(notation(fr,fc,tr,tc,piece,captured));

turn=turn==='w'?'b':'w';
return true;
}

// ============================
// SIMPLE MOVE GENERATION
// (same as previous engine)
// ============================

function getLegal(r,c){
if(!board[r][c]||color(board[r][c])!==turn) return [];
let pseudo=getPseudo(r,c);
return pseudo.filter(m=>{
const snap=JSON.stringify({board,turn,enPassant,castle});
makeMove(r,c,m.r,m.c);
const check=isCheck(turn==='w'?'b':'w');
restore(snap);
return !check;
});
}

function restore(s){
const o=JSON.parse(s);
board=o.board;turn=o.turn;enPassant=o.enPassant;castle=o.castle;
}

// simplified pseudo (full version omitted here for length)
// for brevity assume previous pseudo code logic same as earlier engine

function getPseudo(r,c){
const p=board[r][c];
const side=color(p);
const moves=[];
const add=(rr,cc)=>{
if(rr>=0&&rr<8&&cc>=0&&cc<8&&(!board[rr][cc]||color(board[rr][cc])!==side))
moves.push({r:rr,c:cc});
};
const t=p.toLowerCase();

// pawn
if(t==='p'){
const dir=side==='w'?-1:1;
if(!board[r+dir]?.[c]) add(r+dir,c);
if((side==='w'?r===6:r===1)&&!board[r+dir]?.[c]&&!board[r+2*dir]?.[c])
add(r+2*dir,c);
for(const dc of [-1,1]){
if(board[r+dir]?.[c+dc]&&color(board[r+dir][c+dc])!==side)
add(r+dir,c+dc);
if(enPassant&&enPassant.r===r+dir&&enPassant.c===c+dc)
moves.push({r:r+dir,c:c+dc});
}
}

// knight
if(t==='n'){
[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
.forEach(([dr,dc])=>add(r+dr,c+dc));
}

// rook, bishop, queen similar (omitted for brevity in explanation)

[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
if(t==='r'||t==='q'){
let rr=r+dr,cc=c+dc;
while(rr>=0&&rr<8&&cc>=0&&cc<8){
if(!board[rr][cc]) moves.push({r:rr,c:cc});
else{ if(color(board[rr][cc])!==side) moves.push({r:rr,c:cc}); break; }
rr+=dr;cc+=dc;
}
}
});

[[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{
if(t==='b'||t==='q'){
let rr=r+dr,cc=c+dc;
while(rr>=0&&rr<8&&cc>=0&&cc<8){
if(!board[rr][cc]) moves.push({r:rr,c:cc});
else{ if(color(board[rr][cc])!==side) moves.push({r:rr,c:cc}); break; }
rr+=dr;cc+=dc;
}
}
});

// king
if(t==='k'){
for(let dr=-1;dr<=1;dr++)
for(let dc=-1;dc<=1;dc++)
if(dr||dc) add(r+dr,c+dc);

if(castle[side].k&&!board[r][5]&&!board[r][6])
moves.push({r,c:6});
if(castle[side].q&&!board[r][1]&&!board[r][2]&&!board[r][3])
moves.push({r,c:2});
}

return moves;
}

// ============================
// CHECK
// ============================

function isCheck(side){
let kr,kc;
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]===(side==='w'?'K':'k')){kr=r;kc=c}
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]&&color(board[r][c])!==side)
if(getPseudo(r,c).some(m=>m.r===kr&&m.c===kc))
return true;
return false;
}

// ============================
// BOT
// ============================

function botMove(){
let all=[];
for(let r=0;r<8;r++)
for(let c=0;c<8;c++)
if(board[r][c]&&color(board[r][c])===turn)
getLegal(r,c).forEach(m=>all.push({fr:r,fc:c,tr:m.r,tc:m.c}));
if(all.length===0) return;
const m=all[Math.floor(Math.random()*all.length)];
makeMove(m.fr,m.fc,m.tr,m.tc);
render();
}

function toggleBot(){botEnabled=!botEnabled}

// ============================
// SAVE OPENING
// ============================

function saveOpening(){
localStorage.setItem("myOpening",JSON.stringify(moveHistory));
alert("Opening saved");
}

function loadOpening(){
const data=JSON.parse(localStorage.getItem("myOpening")||"[]");
resetGame();
data.forEach(m=>{
// replay moves naive (simplified)
});
alert("Loaded (manual replay required)");
}

// ============================
// PGN
// ============================

function notation(fr,fc,tr,tc,piece,captured){
return piece.toUpperCase()+String.fromCharCode(97+fc)+(8-fr)+
(captured?'x':'-')+
String.fromCharCode(97+tc)+(8-tr);
}

function exportPGN(){
alert(moveHistory.join(" "));
}

// ============================
// UNDO REDO
// ============================

function saveState(){
undoStack.push(JSON.stringify({board,turn,enPassant,castle,moveHistory}));
redoStack=[];
}

function undoMove(){
if(!undoStack.length) return;
redoStack.push(JSON.stringify({board,turn,enPassant,castle,moveHistory}));
restore(undoStack.pop());
render();
}

function redoMove(){
if(!redoStack.length) return;
undoStack.push(JSON.stringify({board,turn,enPassant,castle,moveHistory}));
restore(redoStack.pop());
render();
}

</script>
</body>
</html>
