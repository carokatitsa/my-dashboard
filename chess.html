<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chess Master - SVG & Flip</title>
    <style>
        :root { --bg: #1a1a1a; --sq-l: #ebecd0; --sq-d: #779556; --hl: rgba(255, 255, 0, 0.5); }
        body { display: flex; background: var(--bg); color: #fff; font-family: 'Segoe UI', sans-serif; margin: 0; padding: 20px; justify-content: center; gap: 40px; }
        #left-pane { display: flex; flex-direction: column; align-items: center; }
        
        /* –î–æ—Å–∫–∞ */
        #board { 
            display: grid; grid-template-columns: repeat(8, 65px); grid-template-rows: repeat(8, 65px); 
            border: 8px solid #333; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.4s ease;
        }
        #board.flipped { transform: rotate(180deg); }
        #board.flipped .piece { transform: rotate(180deg); }

        .square { width: 65px; height: 65px; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
        .white-sq { background-color: var(--sq-l); }
        .black-sq { background-color: var(--sq-d); }
        
        /* SVG –§–∏–≥—É—Ä—ã */
        .piece { width: 90%; height: 90%; background-size: contain; background-repeat: no-repeat; z-index: 2; pointer-events: none; }
        
        .selected { background-color: var(--hl) !important; }
        .can-move::after { content: ""; width: 18px; height: 18px; background: rgba(0,0,0,0.15); border-radius: 50%; position: absolute; }
        
        #right-pane { width: 380px; display: flex; flex-direction: column; gap: 15px; background: #252525; padding: 20px; border-radius: 10px; }
        .mode-toggle { display: flex; border: 2px solid #444; border-radius: 6px; overflow: hidden; }
        .mode-toggle button { flex: 1; border: none; padding: 12px; background: #333; color: #888; cursor: pointer; font-weight: bold; }
        .mode-toggle button.active { background: #27ae60; color: white; }
        .mode-toggle button.active.exam { background: #2980b9; }

        .controls { display: flex; flex-wrap: wrap; gap: 10px; width: 100%; margin-top: 20px;}
        button.action { flex: 1; min-width: 80px; padding: 10px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px; font-weight: bold; }
        button.action:hover { background: #555; }
        
        .save-box { display: flex; flex-direction: column; gap: 8px; background: #1a1a1a; padding: 10px; border-radius: 5px; }
        input { padding: 10px; border-radius: 4px; border: 1px solid #444; background: #111; color: white; }
        .side-select { display: flex; gap: 5px; }
        .side-select button { flex: 1; font-size: 11px; padding: 6px; background: #333; color: white; border: 1px solid #444; cursor: pointer; font-weight: bold; }
        .side-select button.active { background: #555; border-color: #fff; }

        .list-section { height: 180px; overflow-y: auto; border: 1px solid #333; border-radius: 4px; padding: 5px; margin-bottom: 10px; background: #1a1a1a; }
        h4 { margin: 10px 0 5px 0; color: #888; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .debut-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #333; cursor: pointer; font-size: 14px; }
        .debut-item:hover { background: #2a2a2a; }
        .active-debut { background: #1e374a !important; border-left: 4px solid #2980b9; }
        .delete-btn { color: #e74c3c; cursor: pointer; font-weight: bold; padding: 0 5px; }
        #status-bar { padding: 12px; background: #111; border-radius: 4px; font-weight: bold; text-align: center; border: 1px solid #333; min-height: 18px; }
    </style>
</head>
<body>

<div id="left-pane">
    <div id="turn-display" style="margin-bottom: 15px; font-size: 22px; font-weight: bold;">–•–æ–¥ –±–µ–ª—ã—Ö</div>
    <div id="board"></div>
    <div class="controls">
        <button class="action" onclick="undo()">‚¨Ö</button>
        <button class="action" onclick="redo()">‚û°</button>
        <button class="action" onclick="toggleFlip()" style="background: #5c5c5c;">üîÉ –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç</button>
        <button class="action" onclick="resetGame()" style="background: #c0392b;">–°–±—Ä–æ—Å</button>
    </div>
</div>

<div id="right-pane">
    <div class="mode-toggle">
        <button id="mode-record" class="active" onclick="setMode('record')">–ó–ê–ü–ò–°–¨</button>
        <button id="mode-exam" onclick="setMode('exam')">–≠–ö–ó–ê–ú–ï–ù</button>
    </div>

    <div id="status-bar">–†–µ–∂–∏–º: –°–æ–∑–¥–∞–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</div>
    
    <div id="record-tools" class="save-box">
        <input type="text" id="debut-name" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ (–Ω–∞–ø—Ä. –ó–∞—â–∏—Ç–∞ –ü–∏—Ä—Ü–∞)">
        <div class="side-select">
            <button id="btn-w" class="active" onclick="setSaveSide('W')">–Ø –ó–ê –ë–ï–õ–´–•</button>
            <button id="btn-b" onclick="setSaveSide('B')">–Ø –ó–ê –ß–ï–†–ù–´–•</button>
        </div>
        <button class="action" onclick="saveDebut()" style="background: #27ae60;">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç</button>
    </div>
    
    <div id="repertoire">
        <h4>–î–µ–±—é—Ç—ã –∑–∞ –ë–µ–ª—ã—Ö</h4>
        <div id="list-white" class="list-section"></div>
        <h4>–î–µ–±—é—Ç—ã –∑–∞ –ß–µ—Ä–Ω—ã—Ö</h4>
        <div id="list-black" class="list-section"></div>
    </div>
</div>

<script>
    const PIECES_SVG = {
        'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
        'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
        'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
        'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
        'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
        'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
        'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
        'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
        'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
        'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
        'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
        'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg'
    };

    const boardEl = document.getElementById('board');
    const turnEl = document.getElementById('turn-display');
    const statusEl = document.getElementById('status-bar');
    
    const initialBoard = [
        ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''], ['','','','','','','',''],
        ['','','','','','','',''], ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R']
    ];

    let history = [{board: JSON.parse(JSON.stringify(initialBoard)), turn: 'white', castling: {W:{K:true,Q:true}, B:{K:true,Q:true}}, move: null}];
    let historyIndex = 0;
    let selected = null;
    let validMoves = [];
    let mode = 'record';
    let saveSide = 'W';
    let debuts = JSON.parse(localStorage.getItem('chess_v2_data') || '{"W":{}, "B":{}}');
    let activeDebut = null;

    function render() {
        boardEl.innerHTML = '';
        const current = history[historyIndex].board;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0 ? 'white-sq' : 'black-sq'}`;
                if (selected?.r === r && selected?.c === c) sq.classList.add('selected');
                if (validMoves.some(m => m.r === r && m.c === c)) sq.classList.add('can-move');

                const char = current[r][c];
                if (char) {
                    const p = document.createElement('div');
                    p.className = `piece`;
                    p.style.backgroundImage = `url(${PIECES_SVG[char]})`;
                    sq.appendChild(p);
                }
                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
        turnEl.innerText = `–•–æ–¥ ${history[historyIndex].turn === 'white' ? '–ë–ï–õ–´–•' : '–ß–ï–†–ù–´–•'}`;
        updateListsUI();
    }

    function toggleFlip() {
        boardEl.classList.toggle('flipped');
    }

    function setSaveSide(s) {
        saveSide = s;
        document.getElementById('btn-w').classList.toggle('active', s==='W');
        document.getElementById('btn-b').classList.toggle('active', s==='B');
    }

    function setMode(m) {
        mode = m;
        document.getElementById('mode-record').className = m === 'record' ? 'active' : '';
        document.getElementById('mode-exam').className = m === 'exam' ? 'active exam' : '';
        if (m === 'record') {
            statusEl.innerText = "–†–µ–∂–∏–º: –ó–∞–ø–∏—Å—å –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤";
            statusEl.style.color = "#27ae60";
            activeDebut = null;
        }
    }

    function onSquareClick(r, c) {
        const state = history[historyIndex];
        const piece = state.board[r][c];
        const isWhite = piece && piece === piece.toUpperCase();
        const canPick = (state.turn === 'white' && isWhite) || (state.turn === 'black' && piece && !isWhite);

        if (selected) {
            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) { executeMove(selected.r, selected.c, r, c, move.type); return; }
        }
        if (canPick) {
            selected = {r, c};
            validMoves = getValidMoves(r, c, state);
        } else {
            selected = null; validMoves = [];
        }
        render();
    }

    function executeMove(fR, fC, tR, tC, type, isAuto = false) {
        const current = history[historyIndex];
        let newBoard = current.board.map(row => [...row]);
        let newCastling = JSON.parse(JSON.stringify(current.castling));
        const piece = newBoard[fR][fC];

        if (type === 'castle') {
            if (tC === 6) { newBoard[tR][5] = newBoard[tR][7]; newBoard[tR][7] = ''; }
            if (tC === 2) { newBoard[tR][3] = newBoard[tR][0]; newBoard[tR][0] = ''; }
        }
        newBoard[tR][tC] = piece; newBoard[fR][fC] = '';
        if (piece.toLowerCase() === 'p' && (tR === 0 || tR === 7)) newBoard[tR][tC] = piece === 'P' ? 'Q' : 'q';
        if (piece === 'K') newCastling.W = {K:false, Q:false};
        if (piece === 'k') newCastling.B = {K:false, Q:false};

        history = history.slice(0, historyIndex + 1);
        history.push({
            board: newBoard, turn: current.turn === 'white' ? 'black' : 'white',
            castling: newCastling, move: `${fR}${fC}${tR}${tC}`
        });
        historyIndex++; selected = null; validMoves = [];
        render();

        if (mode === 'exam' && activeDebut && !isAuto) checkExam();
    }

    function checkExam() {
        const path = activeDebut.moves;
        if (history[historyIndex].move !== path[historyIndex - 1]) {
            statusEl.innerText = "‚ùå –û—à–∏–±–∫–∞! –ù–µ –ø–æ –≤–∞—Ä–∏–∞–Ω—Ç—É.";
            statusEl.style.color = "#e74c3c";
            return;
        }
        if (path.length > historyIndex) {
            statusEl.innerText = "–í–µ—Ä–Ω–æ! –°–æ–ø–µ—Ä–Ω–∏–∫ —Ö–æ–¥–∏—Ç...";
            setTimeout(() => {
                const m = path[historyIndex];
                executeMove(+m[0], +m[1], +m[2], +m[3], getMoveType(+m[0], +m[1], +m[2], +m[3]), true);
                statusEl.innerText = "–í–∞—à —Ö–æ–¥...";
                statusEl.style.color = "#2980b9";
            }, 600);
        } else {
            statusEl.innerText = "‚úÖ –í–∞—Ä–∏–∞–Ω—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–π–¥–µ–Ω!";
            statusEl.style.color = "#27ae60";
        }
    }

    function selectDebut(side, name) {
        activeDebut = { side, name, moves: debuts[side][name] };
        setMode('exam');
        resetGame();
        
        if (side === 'B') boardEl.classList.add('flipped');
        else boardEl.classList.remove('flipped');

        statusEl.innerText = `–£—á–∏–º: ${name}`;
        if (side === 'B' && activeDebut.moves.length > 0) {
            setTimeout(() => {
                const m = activeDebut.moves[0];
                executeMove(+m[0], +m[1], +m[2], +m[3], getMoveType(+m[0], +m[1], +m[2], +m[3]), true);
            }, 500);
        }
    }

    function getMoveType(fR, fC, tR, tC) {
        const p = history[historyIndex].board[fR][fC].toLowerCase();
        if (p === 'k' && Math.abs(fC - tC) > 1) return 'castle';
        return 'normal';
    }

    function getValidMoves(r, c, state) {
        const moves = []; const b = state.board; const p = b[r][c].toLowerCase(); const isW = b[r][c] === b[r][c].toUpperCase();
        const dirs = {'r':[[0,1],[0,-1],[1,0],[-1,0]], 'b':[[1,1],[1,-1],[-1,1],[-1,-1]], 'q':[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]], 'n':[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]], 'k':[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]};
        if (p === 'p') {
            const s = isW ? -1 : 1;
            if (!b[r+s]?.[c]) {
                moves.push({r:r+s, c:c});
                if (((isW && r===6)||(!isW && r===1)) && !b[r+2*s][c]) moves.push({r:r+2*s, c:c});
            }
            [1,-1].forEach(dc => {
                const target = b[r+s]?.[c+dc];
                if (target && (target === target.toUpperCase()) !== isW) moves.push({r:r+s, c:c+dc});
            });
        } else if (dirs[p]) {
            for (let [dr, dc] of dirs[p]) {
                let nr = r+dr, nc = c+dc;
                while(nr>=0 && nr<8 && nc>=0 && nc<8) {
                    if (!b[nr][nc]) { moves.push({r:nr, c:nc}); if("nk".includes(p)) break; }
                    else { if((b[nr][nc] === b[nr][nc].toUpperCase()) !== isW) moves.push({r:nr, c:nc}); break; }
                    nr += dr; nc += dc;
                }
            }
            if (p === 'k') {
                const cs = isW ? state.castling.W : state.castling.B;
                if (cs.K && !b[r][5] && !b[r][6]) moves.push({r:r, c:6, type:'castle'});
                if (cs.Q && !b[r][1] && !b[r][2] && !b[r][3]) moves.push({r:r, c:2, type:'castle'});
            }
        }
        return moves;
    }

    function saveDebut() {
        const name = document.getElementById('debut-name').value.trim();
        if (!name || history.length < 2) return alert("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ —Å–¥–µ–ª–∞–π—Ç–µ —Ö–æ–¥—ã!");
        debuts[saveSide][name] = history.slice(1).map(h => h.move);
        localStorage.setItem('chess_v2_data', JSON.stringify(debuts));
        document.getElementById('debut-name').value = '';
        updateListsUI();
    }

    function deleteDebut(side, name, e) {
        e.stopPropagation();
        if(confirm(`–£–¥–∞–ª–∏—Ç—å "${name}"?`)) {
            delete debuts[side][name];
            localStorage.setItem('chess_v2_data', JSON.stringify(debuts));
            updateListsUI();
        }
    }

    function updateListsUI() {
        ['W', 'B'].forEach(side => {
            const container = document.getElementById(side === 'W' ? 'list-white' : 'list-black');
            container.innerHTML = '';
            for (let name in debuts[side]) {
                const el = document.createElement('div');
                el.className = `debut-item ${activeDebut?.name === name && activeDebut?.side === side ? 'active-debut' : ''}`;
                el.innerHTML = `<span>${name}</span><span class="delete-btn" onclick="deleteDebut('${side}', '${name}', event)">‚úï</span>`;
                el.onclick = () => selectDebut(side, name);
                container.appendChild(el);
            }
        });
    }

    function undo() { if (historyIndex > 0) { historyIndex--; render(); } }
    function redo() { if (historyIndex < history.length - 1) { historyIndex++; render(); } }
    function resetGame() { history = [history[0]]; historyIndex = 0; selected = null; validMoves = []; render(); }

    render();
    updateListsUI();
</script>
</body>
</html>
