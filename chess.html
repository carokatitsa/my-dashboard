<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Opening Trainer (No Libraries)</title>
<style>
  body { font-family: Arial, sans-serif; margin: 18px; }
  h2 { margin: 0 0 10px; }
  .row { display:flex; gap:14px; flex-wrap: wrap; align-items:flex-start; }
  .panel { min-width: 320px; max-width: 520px; }
  .controls { display:flex; gap:8px; flex-wrap: wrap; margin: 10px 0; }
  button { padding: 7px 12px; cursor: pointer; }
  select, input, textarea { width: 100%; padding: 8px; box-sizing: border-box; }
  textarea { height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .hint { color:#444; font-size: 13px; line-height: 1.35; }

  #board {
    display: grid;
    grid-template-columns: repeat(8, 64px);
    grid-template-rows: repeat(8, 64px);
    width: 512px;
    border: 2px solid #111;
    user-select: none;
    touch-action: manipulation;
  }
  @media (max-width: 560px) {
    #board { grid-template-columns: repeat(8, 44px); grid-template-rows: repeat(8, 44px); width: 352px; }
  }
  .sq {
    display:flex; align-items:center; justify-content:center;
    font-size: 42px;
    cursor: pointer;
  }
  @media (max-width: 560px) { .sq { font-size: 30px; } }

  .w { background: #f0d9b5; }
  .b { background: #b58863; }

  .selected { outline: 3px solid #e11d48; outline-offset: -3px; }
  .hintmove { box-shadow: inset 0 0 0 4px rgba(34,197,94,.55); }
  .capture { box-shadow: inset 0 0 0 4px rgba(239,68,68,.55); }
  .check { box-shadow: inset 0 0 0 4px rgba(59,130,246,.6); }

  .status { margin-top: 8px; font-weight: 600; }
  .small { font-size: 13px; color:#333; }
  code { background:#f2f2f2; padding: 1px 5px; border-radius: 6px; }
</style>
</head>

<body>
<h2>Opening Trainer (–±–µ–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫)</h2>

<div class="row">
  <div>
    <div id="board"></div>
    <div class="controls">
      <button onclick="undoMove()">‚¨Ö –ù–∞–∑–∞–¥</button>
      <button onclick="redoMove()">–í–ø–µ—Ä—ë–¥ ‚û°</button>
      <button onclick="resetAll()">Reset</button>
      <button onclick="toggleAutoOpponent()">Auto-opponent: <span id="autoOpp">ON</span></button>
    </div>
    <div class="status" id="status">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
    <div class="small" id="substatus"></div>
  </div>

  <div class="panel">
    <div class="controls">
      <select id="openingSelect"></select>
      <button onclick="applyOpening()">Start Opening</button>
      <button onclick="deleteOpening()">Delete</button>
    </div>

    <div class="hint">
      –§–æ—Ä–º–∞—Ç —Ö–æ–¥–æ–≤ –¥–µ–±—é—Ç–∞: <b>UCI</b> (–∫–∞–∫ –≤ –¥–≤–∏–∂–∫–∞—Ö), –Ω–∞–ø—Ä–∏–º–µ—Ä:
      <div><code>e2e4 e7e5 g1f3 b8c6 f1b5</code></div>
      –ú–æ–∂–Ω–æ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫, —Å –ø—Ä–æ–±–µ–ª–∞–º–∏ ‚Äî –≤—Å—ë —Ä–∞–≤–Ω–æ –ø–æ–π–º—ë–º.
      <br><br>
      ‚úÖ –í —Ç—Ä–µ–Ω–µ—Ä–µ —Ö–æ–¥ –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞—Å—Ç—å —Å –≤–∞—Ä–∏–∞–Ω—Ç–æ–º ‚Äî –∏–Ω–∞—á–µ –æ—Ç–∫–∞—Ç.
      <br>
      ‚úÖ –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω Auto-opponent, —Ç–æ –ø–æ—Å–ª–µ —Ç–≤–æ–µ–≥–æ —Ö–æ–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å–∞–º–∞ –¥–µ–ª–∞–µ—Ç —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–∞.
    </div>

    <div style="margin-top:10px;">
      <input id="openingName" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–µ–±—é—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: Catalan mainline)" />
    </div>
    <div style="margin-top:8px;">
      <textarea id="openingMoves" placeholder="–í—Å—Ç–∞–≤—å —Ö–æ–¥—ã UCI, –Ω–∞–ø—Ä–∏–º–µ—Ä:
d2d4 d7d5 c2c4 e7e6 g1f3 g8f6 g2g3"></textarea>
    </div>
    <div class="controls">
      <button onclick="saveOpening()">üíæ Save / Update</button>
      <button onclick="exportOpenings()">üì§ Export</button>
      <button onclick="importOpenings()">üì• Import</button>
    </div>
    <div class="small">–≠–∫—Å–ø–æ—Ä—Ç/–∏–º–ø–æ—Ä—Ç ‚Äî JSON —á–µ—Ä–µ–∑ prompt, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Ñ–∞–π–ª–æ–≤/–±–∏–±–ª–∏–æ—Ç–µ–∫.</div>
  </div>
</div>

<script>
/* =========================
   CHESS ENGINE (Minimal but legal)
   - Move legality including "king not left in check"
   - Undo/redo
   - UCI move input
   - No castling / no en-passant (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ)
   - Promotion: –≤—Å–µ–≥–¥–∞ –≤ —Ñ–µ—Ä–∑—è
========================= */

// Piece codes: 'P','N','B','R','Q','K' for White; lowercase for Black
const PIECE_UNI = {
  P:'‚ôô', N:'‚ôò', B:'‚ôó', R:'‚ôñ', Q:'‚ôï', K:'‚ôî',
  p:'‚ôü', n:'‚ôû', b:'‚ôù', r:'‚ôú', q:'‚ôõ', k:'‚ôö'
};

function cloneBoard(b){ return b.map(r => r.slice()); }
function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function isWhite(p){ return p && p === p.toUpperCase(); }
function isBlack(p){ return p && p === p.toLowerCase(); }
function sameColor(a,b){ if(!a||!b) return false; return (isWhite(a)&&isWhite(b))||(isBlack(a)&&isBlack(b)); }

function sqToRC(sq){
  // 'a1' -> row=7,col=0 ; 'a8' -> row=0,col=0
  const file = sq.charCodeAt(0) - 97;
  const rank = parseInt(sq[1],10);
  return { r: 8-rank, c: file };
}
function rcToSq(r,c){
  return String.fromCharCode(97+c) + (8-r);
}

const START = [
  ['r','n','b','q','k','b','n','r'],
  ['p','p','p','p','p','p','p','p'],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['P','P','P','P','P','P','P','P'],
  ['R','N','B','Q','K','B','N','R']
];

let enPassantTarget = null;

let castlingRights = {
  white: { kingSide: true, queenSide: true },
  black: { kingSide: true, queenSide: true }
};
  
let board = cloneBoard(START);
let turn = 'w'; // 'w' or 'b'
let selected = null;
let legalTargets = [];
let undoStack = [];
let redoStack = [];
let autoOpponent = true;

// Opening trainer state
let openings = {};
let currentOpeningName = '';
let openingLine = [];      // array of UCI moves
let openingIndex = 0;      // next expected ply (0-based)
let strictTrainer = true;  // if move not in line => reject

/* =========================
   Attack / Check helpers
========================= */
function findKing(b, side){
  const target = (side==='w') ? 'K' : 'k';
  for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(b[r][c]===target) return {r,c};
  return null;
}

function isSquareAttacked(b, r, c, bySide){
  // bySide attacks (bySide==='w' means white pieces attack)
  const pawnDir = (bySide==='w') ? -1 : 1;
  const pawn = (bySide==='w') ? 'P' : 'p';
  const knight = (bySide==='w') ? 'N' : 'n';
  const bishop = (bySide==='w') ? 'B' : 'b';
  const rook = (bySide==='w') ? 'R' : 'r';
  const queen = (bySide==='w') ? 'Q' : 'q';
  const king = (bySide==='w') ? 'K' : 'k';

  // Pawns
  for(const dc of [-1,1]){
    const rr = r - pawnDir;
    const cc = c - dc;
    if(inBounds(rr,cc) && b[rr][cc]===pawn) return true;
  }

  // Knights
  const kD = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
  for(const [dr,dc] of kD){
    const rr=r+dr, cc=c+dc;
    if(inBounds(rr,cc) && b[rr][cc]===knight) return true;
  }

  // Bishops / Queens diagonals
  const diag = [[-1,-1],[-1,1],[1,-1],[1,1]];
  for(const [dr,dc] of diag){
    let rr=r+dr, cc=c+dc;
    while(inBounds(rr,cc)){
      const p=b[rr][cc];
      if(p){
        if(p===bishop || p===queen) return true;
        break;
      }
      rr+=dr; cc+=dc;
    }
  }

  // Rooks / Queens lines
  const line = [[-1,0],[1,0],[0,-1],[0,1]];
  for(const [dr,dc] of line){
    let rr=r+dr, cc=c+dc;
    while(inBounds(rr,cc)){
      const p=b[rr][cc];
      if(p){
        if(p===rook || p===queen) return true;
        break;
      }
      rr+=dr; cc+=dc;
    }
  }

  // Kings (adjacent)
  for(let dr=-1;dr<=1;dr++){
    for(let dc=-1;dc<=1;dc++){
      if(dr===0 && dc===0) continue;
      const rr=r+dr, cc=c+dc;
      if(inBounds(rr,cc) && b[rr][cc]===king) return true;
    }
  }

  return false;
}

function inCheck(b, side){
  const k = findKing(b, side);
  if(!k) return false;
  const attacker = (side==='w') ? 'b' : 'w';
  return isSquareAttacked(b, k.r, k.c, attacker);
}

/* =========================
   Move generation
========================= */
function genPseudoMoves(b, r, c){
  const p = b[r][c];
  if(!p) return [];
  const side = isWhite(p) ? 'w' : 'b';
  const enemy = (side==='w') ? isBlack : isWhite;
  const moves = [];

  const add = (rr,cc) => { if(inBounds(rr,cc) && !sameColor(p,b[rr][cc])) moves.push({from:{r,c},to:{r:rr,c:cc}}); };

  const type = p.toLowerCase();
  if(type==='p'){
    const dir = (side==='w') ? -1 : 1;
    const startRow = (side==='w') ? 6 : 1;
    // forward 1
    const r1=r+dir;
    if(inBounds(r1,c) && b[r1][c]===''){
      moves.push({from:{r,c},to:{r:r1,c}});
      // forward 2
      const r2=r+2*dir;
      if(r===startRow && inBounds(r2,c) && b[r2][c]==='') moves.push({from:{r,c},to:{r:r2,c}});
    }
    // captures
    for(const dc of [-1,1]){
      const rr=r+dir, cc=c+dc;
      if(inBounds(rr,cc) && b[rr][cc]!=='' && enemy(b[rr][cc])) moves.push({from:{r,c},to:{r:rr,c:cc}});
    }
  }

  if(type==='n'){
    const kD = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    for(const [dr,dc] of kD) add(r+dr,c+dc);
  }

  if(type==='b' || type==='q'){
    const diag = [[-1,-1],[-1,1],[1,-1],[1,1]];
    for(const [dr,dc] of diag){
      let rr=r+dr, cc=c+dc;
      while(inBounds(rr,cc)){
        if(b[rr][cc]===''){ moves.push({from:{r,c},to:{r:rr,c:cc}}); }
        else { if(!sameColor(p,b[rr][cc])) moves.push({from:{r,c},to:{r:rr,c:cc}}); break; }
        rr+=dr; cc+=dc;
      }
    }
  }

  if(type==='r' || type==='q'){
    const line = [[-1,0],[1,0],[0,-1],[0,1]];
    for(const [dr,dc] of line){
      let rr=r+dr, cc=c+dc;
      while(inBounds(rr,cc)){
        if(b[rr][cc]===''){ moves.push({from:{r,c},to:{r:rr,c:cc}}); }
        else { if(!sameColor(p,b[rr][cc])) moves.push({from:{r,c},to:{r:rr,c:cc}}); break; }
        rr+=dr; cc+=dc;
      }
    }
  }

  if(type==='k'){
    for(let dr=-1;dr<=1;dr++){
      for(let dc=-1;dc<=1;dc++){
        if(dr===0 && dc===0) continue;
        add(r+dr,c+dc);
      }
    
    // ===== –†–û–ö–ò–†–û–í–ö–ê =====
    if(side === 'w' && r === 7 && c === 4){
        // –∫–æ—Ä–æ—Ç–∫–∞—è
        if(b[7][5]==='' && b[7][6]==='' && b[7][7]==='R'){
            moves.push({from:{r,c}, to:{r:7,c:6}});
        }
        // –¥–ª–∏–Ω–Ω–∞—è
        if(b[7][1]==='' && b[7][2]==='' && b[7][3]==='' && b[7][0]==='R'){
            moves.push({from:{r,c}, to:{r:7,c:2}});
        }
    }

    if(side === 'b' && r === 0 && c === 4){
        // –∫–æ—Ä–æ—Ç–∫–∞—è
        if(b[0][5]==='' && b[0][6]==='' && b[0][7]==='r'){
            moves.push({from:{r,c}, to:{r:0,c:6}});
        }
        // –¥–ª–∏–Ω–Ω–∞—è
        if(b[0][1]==='' && b[0][2]==='' && b[0][3]==='' && b[0][0]==='r'){
            moves.push({from:{r,c}, to:{r:0,c:2}});
        }
    }
}
  }

  return moves;
}

function genLegalMovesForSquare(r,c){
  const p = board[r][c];
  if(!p) return [];
  const side = isWhite(p) ? 'w' : 'b';
  if(side !== turn) return [];
  const pseudo = genPseudoMoves(board, r, c);

  // Filter moves that leave king in check
  const legal = [];
  for(const m of pseudo){
    const nb = cloneBoard(board);
    const moved = nb[r][c];
    nb[r][c] = '';
    nb[m.to.r][m.to.c] = moved;

    // Promotion: pawn reaches last rank -> queen
    if(moved.toLowerCase()==='p'){
      if((side==='w' && m.to.r===0) || (side==='b' && m.to.r===7)){
        nb[m.to.r][m.to.c] = (side==='w') ? 'Q' : 'q';
      }
    }

    if(!inCheck(nb, side)) legal.push(m);
  }
  return legal;
}

/* =========================
   Apply move + history
========================= */
function makeMove(fromR, fromC, toR, toC){
  const legal = genLegalMovesForSquare(fromR, fromC);
  const ok = legal.find(m => m.to.r===toR && m.to.c===toC);
  if(!ok) return null;

  const piece = board[fromR][fromC];
  const captured = board[toR][toC] || '';
  const before = { board: cloneBoard(board), turn, openingIndex };

  // move
  board[fromR][fromC] = '';
  board[toR][toC] = piece;

// –†–û–ö–ò–†–û–í–ö–ê
if(piece.toLowerCase() === 'k' && Math.abs(toC - fromC) === 2){
    if(toC === 6){ // –∫–æ—Ä–æ—Ç–∫–∞—è
        board[toR][5] = board[toR][7];
        board[toR][7] = '';
    }
    if(toC === 2){ // –¥–ª–∏–Ω–Ω–∞—è
        board[toR][3] = board[toR][0];
        board[toR][0] = '';
    }
}

// –í–ó–Ø–¢–ò–ï –ù–ê –ü–†–û–•–û–î–ï
if(piece.toLowerCase() === 'p'){
    if(fromC !== toC && captured === ''){
        if(turn === 'w'){
            board[toR+1][toC] = '';
        } else {
            board[toR-1][toC] = '';
        }
    }
}


  
  // promotion
  if(piece.toLowerCase()==='p'){
    if((turn==='w' && toR===0) || (turn==='b' && toR===7)){
      board[toR][toC] = (turn==='w') ? 'Q' : 'q';
    }
  }

  turn = (turn==='w') ? 'b' : 'w';

  // history
  undoStack.push(before);
  redoStack = [];

  return { from: rcToSq(fromR,fromC), to: rcToSq(toR,toC), piece, captured };
}

function undoMove(){
  if(undoStack.length===0) return;
  const last = undoStack.pop();
  const snapshot = { board: cloneBoard(board), turn, openingIndex };
  redoStack.push(snapshot);

  board = cloneBoard(last.board);
  turn = last.turn;
  openingIndex = last.openingIndex;

  selected = null; legalTargets = [];
  draw();
}

function redoMove(){
  if(redoStack.length===0) return;
  const next = redoStack.pop();
  const snapshot = { board: cloneBoard(board), turn, openingIndex };
  undoStack.push(snapshot);

  board = cloneBoard(next.board);
  turn = next.turn;
  openingIndex = next.openingIndex;

  selected = null; legalTargets = [];
  draw();
}

/* =========================
   UI board drawing
========================= */
const boardEl = document.getElementById('board');

function clearHighlights(){
  for(const el of boardEl.querySelectorAll('.sq')){
    el.classList.remove('selected','hintmove','capture','check');
  }
}

function draw(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq = document.createElement('div');
      sq.className = 'sq ' + (((r+c)%2===0)?'w':'b');
      sq.dataset.r = r;
      sq.dataset.c = c;
      const p = board[r][c];
      sq.textContent = p ? PIECE_UNI[p] : '';
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
  }

  // show if side in check
  if(inCheck(board, turn)){
    const k = findKing(board, turn);
    if(k){
      const el = getSquareEl(k.r,k.c);
      if(el) el.classList.add('check');
    }
  }

  updateStatus();
  highlightNextExpected();
}

function getSquareEl(r,c){
  return boardEl.querySelector(`.sq[data-r="${r}"][data-c="${c}"]`);
}

function onSquareClick(e){
  const r = parseInt(e.currentTarget.dataset.r,10);
  const c = parseInt(e.currentTarget.dataset.c,10);
  const p = board[r][c];

  // If nothing selected -> select own piece
  if(!selected){
    if(!p) return;
    if(turn==='w' && !isWhite(p)) return;
    if(turn==='b' && !isBlack(p)) return;

    selected = {r,c};
    legalTargets = genLegalMovesForSquare(r,c).map(m => m.to);

    clearHighlights();
    e.currentTarget.classList.add('selected');
    for(const t of legalTargets){
      const el = getSquareEl(t.r,t.c);
      if(!el) continue;
      if(board[t.r][t.c] !== '') el.classList.add('capture');
      else el.classList.add('hintmove');
    }
    return;
  }

  // If selected -> attempt move or change selection
  if(selected){
    // click same color piece -> change selection
    if(p && ((turn==='w' && isWhite(p)) || (turn==='b' && isBlack(p)))){
      selected = null; legalTargets=[];
      clearHighlights();
      onSquareClick(e);
      return;
    }

    const moved = tryTrainerMove(selected.r, selected.c, r, c);
    selected = null; legalTargets=[];
    clearHighlights();
    if(moved) draw();
  }
}

/* =========================
   Opening trainer logic (UCI)
========================= */
function normalizeMoves(text){
  return text
    .replace(/[\n\r\t]+/g,' ')
    .replace(/,+/g,' ')
    .trim()
    .split(/\s+/)
    .filter(Boolean);
}

function uciFromTo(fromSq,toSq){ return fromSq+toSq; }

function tryTrainerMove(fr,fc,tr,tc){
  const moveUci = uciFromTo(rcToSq(fr,fc), rcToSq(tr,tc));
  const expected = openingLine[openingIndex] || null;

  // if trainer active and expects move
  if(strictTrainer && openingLine.length>0){
    if(expected && expected !== moveUci){
      // reject (snapback)
      flashStatus(`–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ: –æ–∂–∏–¥–∞–ª—Å—è ${expected}, —Ç—ã —Å–¥–µ–ª–∞–ª ${moveUci}`);
      return false;
    }
  }

  const mv = makeMove(fr,fc,tr,tc);
  if(!mv){
    flashStatus('–ù–µ–ª–µ–≥–∞–ª—å–Ω—ã–π —Ö–æ–¥ (–ø–æ –ø—Ä–∞–≤–∏–ª–∞–º).');
    return false;
  }

  // advance opening ply if matches
  if(openingLine.length>0){
    const exp = openingLine[openingIndex] || null;
    if(exp === moveUci) openingIndex++;
  }

  // auto opponent reply
  if(autoOpponent) maybePlayOpponent();

  return true;
}

function maybePlayOpponent(){
  if(openingLine.length===0) return;
  const next = openingLine[openingIndex];
  if(!next) return;

  // next move should be by side to move; we just play it if legal
  const fr = sqToRC(next.slice(0,2));
  const to = sqToRC(next.slice(2,4));
  const mv = makeMove(fr.r, fr.c, to.r, to.c);
  if(mv){
    openingIndex++;
  } else {
    flashStatus(`–í–∞—Ä–∏–∞–Ω—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–ª–µ–≥–∞–ª—å–Ω—ã–π —Ö–æ–¥: ${next} (–ø—Ä–æ–≤–µ—Ä—å –¥–µ–±—é—Ç)`);
  }
}

/* =========================
   Status + Next expected highlight
========================= */
let statusTimer = null;
function flashStatus(msg){
  const st = document.getElementById('status');
  st.textContent = msg;
  st.style.color = '#c2410c';
  clearTimeout(statusTimer);
  statusTimer = setTimeout(()=>{ st.style.color = '#111'; updateStatus(); }, 1800);
}

function updateStatus(){
  const st = document.getElementById('status');
  const sub = document.getElementById('substatus');

  const sideText = (turn==='w') ? '–•–æ–¥ –±–µ–ª—ã—Ö' : '–•–æ–¥ —á—ë—Ä–Ω—ã—Ö';
  const checkText = inCheck(board, turn) ? ' ‚Äî –®–ê–•!' : '';
  st.textContent = sideText + checkText;

  if(openingLine.length>0){
    const next = openingLine[openingIndex] || '(–∫–æ–Ω–µ—Ü –≤–∞—Ä–∏–∞–Ω—Ç–∞)';
    sub.textContent = `–î–µ–±—é—Ç: ${currentOpeningName || '‚Äî'} | —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥: ${next} | ply: ${openingIndex}/${openingLine.length}`;
  } else {
    sub.textContent = `–î–µ–±—é—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω (–º–æ–∂–µ—à—å –¥–æ–±–∞–≤–∏—Ç—å —Å–≤–æ–π —Å–ø—Ä–∞–≤–∞).`;
  }
}

function highlightNextExpected(){
  if(openingLine.length===0) return;
  const next = openingLine[openingIndex];
  if(!next) return;

  // highlight FROM square of expected move for side to move
  const fr = sqToRC(next.slice(0,2));
  const el = getSquareEl(fr.r, fr.c);
  if(el) el.classList.add('selected');
}

/* =========================
   Openings storage
========================= */
function defaultOpenings(){
  return {
    "Catalan (sample)": "d2d4 d7d5 c2c4 e7e6 g1f3 g8f6 g2g3",
    "Italian (sample)": "e2e4 e7e5 g1f3 b8c6 f1c4 f8c5",
    "QGD (sample)": "d2d4 d7d5 c2c4 e7e6 b1c3 g8f6"
  };
}

function loadOpenings(){
  try{
    const raw = localStorage.getItem('my_openings_v1');
    openings = raw ? JSON.parse(raw) : defaultOpenings();
  }catch(e){
    openings = defaultOpenings();
  }
  refreshOpeningSelect();
}

function saveOpenings(){
  localStorage.setItem('my_openings_v1', JSON.stringify(openings));
}

function refreshOpeningSelect(){
  const sel = document.getElementById('openingSelect');
  sel.innerHTML = '';
  const names = Object.keys(openings).sort((a,b)=>a.localeCompare(b));
  const opt0 = document.createElement('option');
  opt0.value = '';
  opt0.textContent = '‚Äî –≤—ã–±–µ—Ä–∏ –¥–µ–±—é—Ç ‚Äî';
  sel.appendChild(opt0);

  for(const n of names){
    const o = document.createElement('option');
    o.value = n;
    o.textContent = n;
    sel.appendChild(o);
  }
  sel.addEventListener('change', ()=>{
    const name = sel.value;
    if(!name) return;
    document.getElementById('openingName').value = name;
    document.getElementById('openingMoves').value = openings[name];
  });
}

function saveOpening(){
  const name = document.getElementById('openingName').value.trim();
  const movesText = document.getElementById('openingMoves').value.trim();
  if(!name){ flashStatus('–î–∞–π –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–µ–±—é—Ç—É.'); return; }
  const moves = normalizeMoves(movesText);
  if(moves.length===0){ flashStatus('–í—Å—Ç–∞–≤—å —Ö–æ–¥—ã (UCI).'); return; }

  openings[name] = moves.join(' ');
  saveOpenings();
  refreshOpeningSelect();
  flashStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ‚úÖ');
}

function deleteOpening(){
  const name = document.getElementById('openingSelect').value || document.getElementById('openingName').value.trim();
  if(!name || !openings[name]){ flashStatus('–ù–µ—á–µ–≥–æ —É–¥–∞–ª—è—Ç—å.'); return; }
  if(!confirm(`–£–¥–∞–ª–∏—Ç—å "${name}"?`)) return;
  delete openings[name];
  saveOpenings();
  refreshOpeningSelect();
  document.getElementById('openingName').value='';
  document.getElementById('openingMoves').value='';
  flashStatus('–£–¥–∞–ª–µ–Ω–æ.');
}

function applyOpening(){
  const sel = document.getElementById('openingSelect').value;
  const name = sel || document.getElementById('openingName').value.trim();
  if(!name || !openings[name]){ flashStatus('–í—ã–±–µ—Ä–∏ –¥–µ–±—é—Ç –∏–∑ —Å–ø–∏—Å–∫–∞.'); return; }
  currentOpeningName = name;
  openingLine = normalizeMoves(openings[name]);
  openingIndex = 0;

  // reset position
  board = cloneBoard(START);
  turn = 'w';
  undoStack = [];
  redoStack = [];
  selected = null;
  legalTargets = [];

  draw();
  flashStatus(`–°—Ç–∞—Ä—Ç: ${name}`);
}

function exportOpenings(){
  const data = JSON.stringify(openings, null, 2);
  prompt('–°–∫–æ–ø–∏—Ä—É–π JSON (—ç–∫—Å–ø–æ—Ä—Ç):', data);
}

function importOpenings(){
  const raw = prompt('–í—Å—Ç–∞–≤—å JSON (–∏–º–ø–æ—Ä—Ç):');
  if(!raw) return;
  try{
    const obj = JSON.parse(raw);
    if(typeof obj !== 'object' || Array.isArray(obj)) throw new Error('bad');
    openings = obj;
    saveOpenings();
    refreshOpeningSelect();
    flashStatus('–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ ‚úÖ');
  }catch(e){
    flashStatus('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ (JSON).');
  }
}

/* =========================
   Misc controls
========================= */
function resetAll(){
  board = cloneBoard(START);
  turn = 'w';
  undoStack = [];
  redoStack = [];
  selected = null;
  legalTargets = [];
  openingIndex = 0;
  draw();
}

function toggleAutoOpponent(){
  autoOpponent = !autoOpponent;
  document.getElementById('autoOpp').textContent = autoOpponent ? 'ON' : 'OFF';
  flashStatus(`Auto-opponent: ${autoOpponent ? 'ON' : 'OFF'}`);
}

/* =========================
   Init
========================= */
document.getElementById('autoOpp').textContent = autoOpponent ? 'ON' : 'OFF';
loadOpenings();
draw();
</script>
</body>
</html>
