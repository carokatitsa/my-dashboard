<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шахматы JS - Полная версия</title>
    <style>
        :root {
            --bg-dark: #2c3e50;
            --sq-white: #dee3e6;
            --sq-black: #8ca2ad;
            --hl-select: rgba(241, 196, 15, 0.7);
            --hl-move: rgba(46, 204, 113, 0.5);
        }
        body {
            display: flex; flex-direction: column; align-items: center;
            background: var(--bg-dark); color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; padding-top: 20px;
        }
        #status { margin-bottom: 15px; font-size: 20px; font-weight: bold; }
        #board {
            display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px);
            border: 5px solid #34495e; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .square {
            width: 60px; height: 60px; display: flex; justify-content: center;
            align-items: center; font-size: 45px; cursor: pointer; position: relative;
        }
        .white { background-color: var(--sq-white); }
        .black { background-color: var(--sq-black); }
        .selected { background-color: var(--hl-select) !important; }
        .can-move::after {
            content: ""; width: 20px; height: 20px; background: var(--hl-move); border-radius: 50%;
        }
        .piece { z-index: 2; transition: transform 0.2s; }
        .piece:hover { transform: scale(1.1); }
    </style>
</head>
<body>

    <div id="status">Ход белых</div>
    <div id="board"></div>
    <p style="color: #bdc3c7; font-size: 0.9rem;">Правила: Рокировка, Взятие на проходе, Превращение пешек включены.</p>

<script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    
    const PIECES = {
        'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
        'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
    };

    let board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];

    let turn = 'white';
    let selected = null;
    let validMoves = [];
    let enPassantTarget = null; 
    let castling = { W: {K:true, Q:true}, B: {K:true, Q:true} };

    function init() {
        render();
    }

    function render() {
        boardEl.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0 ? 'white' : 'black'}`;
                if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');
                
                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) sq.classList.add('can-move');

                if (board[r][c]) {
                    const p = document.createElement('span');
                    p.className = 'piece';
                    p.innerText = PIECES[board[r][c]];
                    sq.appendChild(p);
                }

                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
    }

    function onSquareClick(r, c) {
        const piece = board[r][c];
        const isWhite = piece && piece === piece.toUpperCase();
        const myTurn = (turn === 'white' && isWhite) || (turn === 'black' && piece && !isWhite);

        if (selected) {
            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                executeMove(selected.r, selected.c, r, c, move.type);
                return;
            }
        }

        if (myTurn) {
            selected = {r, c};
            validMoves = getValidMoves(r, c);
        } else {
            selected = null;
            validMoves = [];
        }
        render();
    }

    function getValidMoves(r, c) {
        const piece = board[r][c];
        const type = piece.toLowerCase();
        const isWhite = piece === piece.toUpperCase();
        const moves = [];

        const directions = {
            'r': [[0,1],[0,-1],[1,0],[-1,0]],
            'b': [[1,1],[1,-1],[-1,1],[-1,-1]],
            'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
            'q': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            'k': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };

        if (type === 'p') {
            const dir = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            // Вперед
            if (!board[r+dir][c]) {
                moves.push({r: r+dir, c: c});
                if (r === startRow && !board[r+2*dir][c]) moves.push({r: r+2*dir, c: c});
            }
            // Атака
            [[dir, 1], [dir, -1]].forEach(([dr, dc]) => {
                const nr = r+dr, nc = c+dc;
                if (nc>=0 && nc<8) {
                    const target = board[nr][nc];
                    if (target && (isWhite !== (target === target.toUpperCase()))) moves.push({r: nr, c: nc});
                    // En Passant
                    if (enPassantTarget && nr === enPassantTarget.r && nc === enPassantTarget.c) {
                        moves.push({r: nr, c: nc, type: 'ep'});
                    }
                }
            });
        } else if (directions[type]) {
            for (let [dr, dc] of directions[type]) {
                let nr = r + dr, nc = c + dc;
                while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                    const target = board[nr][nc];
                    if (!target) {
                        moves.push({r: nr, c: nc});
                        if (type === 'n' || type === 'k') break;
                    } else {
                        if (isWhite !== (target === target.toUpperCase())) moves.push({r: nr, c: nc});
                        break;
                    }
                    nr += dr; nc += dc;
                }
            }
            // Рокировка (упрощенно)
            if (type === 'k') {
                const side = isWhite ? 'W' : 'B';
                const row = isWhite ? 7 : 0;
                if (castling[side].K && !board[row][5] && !board[row][6]) moves.push({r: row, c: 6, type: 'castle'});
                if (castling[side].Q && !board[row][1] && !board[row][2] && !board[row][3]) moves.push({r: row, c: 2, type: 'castle'});
            }
        }
        return moves;
    }

    function executeMove(fR, fC, tR, tC, special) {
        const piece = board[fR][fC];
        
        // Обработка спец-ходов
        if (special === 'ep') {
            board[fR][tC] = ''; // Удаляем пешку при взятии на проходе
        }
        if (special === 'castle') {
            if (tC === 6) { board[fR][5] = board[fR][7]; board[fR][7] = ''; }
            if (tC === 2) { board[fR][3] = board[fR][0]; board[fR][0] = ''; }
        }

        // Движение фигуры
        board[tR][tC] = piece;
        board[fR][fC] = '';

        // Превращение пешки
        if (piece.toLowerCase() === 'p' && (tR === 0 || tR === 7)) {
            board[tR][tC] = piece === 'P' ? 'Q' : 'q';
        }

        // Сброс прав на рокировку
        if (piece === 'K') castling.W = {K:false, Q:false};
        if (piece === 'k') castling.B = {K:false, Q:false};

        // En Passant target
        enPassantTarget = (piece.toLowerCase() === 'p' && Math.abs(tR - fR) === 2) 
            ? {r: (fR + tR) / 2, c: fC} : null;

        turn = turn === 'white' ? 'black' : 'white';
        statusEl.innerText = `Ход ${turn === 'white' ? 'белых' : 'черных'}`;
        selected = null;
        validMoves = [];
        render();
    }

    init();
</script>
</body>
</html>
